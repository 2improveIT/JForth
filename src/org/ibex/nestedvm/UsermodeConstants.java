// THIS FILE IS AUTOGENERATED! DO NOT EDIT!
// run "make rebuild-constants" if it needs to be updated

package org.ibex.nestedvm;
public interface UsermodeConstants {
    int SYS_null = 0;
    int SYS_exit = 1;
    int SYS_pause = 2;
    int SYS_open = 3;
    int SYS_close = 4;
    int SYS_read = 5;
    int SYS_write = 6;
    int SYS_sbrk = 7;
    int SYS_fstat = 8;
    int SYS_lseek = 10;
    int SYS_kill = 11;
    int SYS_getpid = 12;
    int SYS_calljava = 13;
    int SYS_stat = 14;
    int SYS_gettimeofday = 15;
    int SYS_sleep = 16;
    int SYS_times = 17;
    int SYS_mkdir = 18;
    int SYS_getpagesize = 19;
    int SYS_unlink = 20;
    int SYS_utime = 21;
    int SYS_chdir = 22;
    int SYS_pipe = 23;
    int SYS_dup2 = 24;
    int SYS_fork = 25;
    int SYS_waitpid = 26;
    int SYS_getcwd = 27;
    int SYS_exec = 28;
    int SYS_fcntl = 29;
    int SYS_rmdir = 30;
    int SYS_sysconf = 31;
    int SYS_readlink = 32;
    int SYS_lstat = 33;
    int SYS_symlink = 34;
    int SYS_link = 35;
    int SYS_getdents = 36;
    int SYS_memcpy = 37;
    int SYS_memset = 38;
    int SYS_dup = 39;
    int SYS_vfork = 40;
    int SYS_chroot = 41;
    int SYS_mknod = 42;
    int SYS_lchown = 43;
    int SYS_ftruncate = 44;
    int SYS_usleep = 45;
    int SYS_getppid = 46;
    int SYS_mkfifo = 47;
    int SYS_klogctl = 51;
    int SYS_realpath = 52;
    int SYS_sysctl = 53;
    int SYS_setpriority = 54;
    int SYS_getpriority = 55;
    int SYS_socket = 56;
    int SYS_connect = 57;
    int SYS_resolve_hostname = 58;
    int SYS_accept = 59;
    int SYS_setsockopt = 60;
    int SYS_getsockopt = 61;
    int SYS_listen = 62;
    int SYS_bind = 63;
    int SYS_shutdown = 64;
    int SYS_sendto = 65;
    int SYS_recvfrom = 66;
    int SYS_select = 67;
    int SYS_getuid = 68;
    int SYS_getgid = 69;
    int SYS_geteuid = 70;
    int SYS_getegid = 71;
    int SYS_getgroups = 72;
    int SYS_umask = 73;
    int SYS_chmod = 74;
    int SYS_fchmod = 75;
    int SYS_chown = 76;
    int SYS_fchown = 77;
    int SYS_access = 78;
    int SYS_alarm = 79;
    int SYS_setuid = 80;
    int SYS_setgid = 81;
    int SYS_send = 82;
    int SYS_recv = 83;
    int SYS_getsockname = 84;
    int SYS_getpeername = 85;
    int SYS_seteuid = 86;
    int SYS_setegid = 87;
    int SYS_setgroups = 88;
    int SYS_resolve_ip = 89;
    int SYS_setsid = 90;
    int SYS_fsync = 91;
    int AF_UNIX = 1;
    int AF_INET = 2;
    int SOCK_STREAM = 1;
    int SOCK_DGRAM = 2;
    int HOST_NOT_FOUND = 1;
    int TRY_AGAIN = 2;
    int NO_RECOVERY = 3;
    int NO_DATA = 4;
    int SOL_SOCKET = 0xffff;
    int SO_REUSEADDR = 0x0004;
    int SO_KEEPALIVE = 0x0008;
    int SO_BROADCAST = 0x0020;
    int SO_TYPE = 0x1008;
    int SHUT_RD = 0;
    int SHUT_WR = 1;
    int SHUT_RDWR = 2;
    int INADDR_ANY = 0;
    int INADDR_LOOPBACK = 0x7f000001;
    int INADDR_BROADCAST = 0xffffffff;
    int EPERM = 1; /* Not super-user */
    int ENOENT = 2; /* No such file or directory */
    int ESRCH = 3; /* No such process */
    int EINTR = 4; /* Interrupted system call */
    int EIO = 5; /* I/O error */
    int ENXIO = 6; /* No such device or address */
    int E2BIG = 7; /* Arg list too long */
    int ENOEXEC = 8; /* Exec format error */
    int EBADF = 9; /* Bad file number */
    int ECHILD = 10; /* No children */
    int EAGAIN = 11; /* No more processes */
    int ENOMEM = 12; /* Not enough core */
    int EACCES = 13; /* Permission denied */
    int EFAULT = 14; /* Bad address */
    int ENOTBLK = 15; /* Block device required */
    int EBUSY = 16; /* Mount device busy */
    int EEXIST = 17; /* File exists */
    int EXDEV = 18; /* Cross-device link */
    int ENODEV = 19; /* No such device */
    int ENOTDIR = 20; /* Not a directory */
    int EISDIR = 21; /* Is a directory */
    int EINVAL = 22; /* Invalid argument */
    int ENFILE = 23; /* Too many open files in system */
    int EMFILE = 24; /* Too many open files */
    int ENOTTY = 25; /* Not a typewriter */
    int ETXTBSY = 26; /* Text file busy */
    int EFBIG = 27; /* File too large */
    int ENOSPC = 28; /* No space left on device */
    int ESPIPE = 29; /* Illegal seek */
    int EROFS = 30; /* Read only file system */
    int EMLINK = 31; /* Too many links */
    int EPIPE = 32; /* Broken pipe */
    int EDOM = 33; /* Math arg out of domain of func */
    int ERANGE = 34; /* Math result not representable */
    int ENOMSG = 35; /* No message of desired type */
    int EIDRM = 36; /* Identifier removed */
    int ECHRNG = 37; /* Channel number out of range */
    int EL2NSYNC = 38; /* Level 2 not synchronized */
    int EL3HLT = 39; /* Level 3 halted */
    int EL3RST = 40; /* Level 3 reset */
    int ELNRNG = 41; /* Link number out of range */
    int EUNATCH = 42; /* Protocol driver not attached */
    int ENOCSI = 43; /* No CSI structure available */
    int EL2HLT = 44; /* Level 2 halted */
    int EDEADLK = 45; /* Deadlock condition */
    int ENOLCK = 46; /* No record locks available */
    int EBADE = 50; /* Invalid exchange */
    int EBADR = 51; /* Invalid request descriptor */
    int EXFULL = 52; /* Exchange full */
    int ENOANO = 53; /* No anode */
    int EBADRQC = 54; /* Invalid request code */
    int EBADSLT = 55; /* Invalid slot */
    int EDEADLOCK = 56; /* File locking deadlock error */
    int EBFONT = 57; /* Bad font file fmt */
    int ENOSTR = 60; /* Device not a stream */
    int ENODATA = 61; /* No data (for no delay io) */
    int ETIME = 62; /* Timer expired */
    int ENOSR = 63; /* Out of streams resources */
    int ENONET = 64; /* Machine is not on the network */
    int ENOPKG = 65; /* Package not installed */
    int EREMOTE = 66; /* The object is remote */
    int ENOLINK = 67; /* The link has been severed */
    int EADV = 68; /* Advertise error */
    int ESRMNT = 69; /* Srmount error */
    int ECOMM = 70; /* Communication error on send */
    int EPROTO = 71; /* Protocol error */
    int EMULTIHOP = 74; /* Multihop attempted */
    int ELBIN = 75; /* Inode is remote (not really error) */
    int EDOTDOT = 76; /* Cross mount point (not really error) */
    int EBADMSG = 77; /* Trying to read unreadable message */
    int EFTYPE = 79; /* Inappropriate file type or format */
    int ENOTUNIQ = 80; /* Given log. name not unique */
    int EBADFD = 81; /* f.d. invalid for this operation */
    int EREMCHG = 82; /* Remote address changed */
    int ELIBACC = 83; /* Can't access a needed shared lib */
    int ELIBBAD = 84; /* Accessing a corrupted shared lib */
    int ELIBSCN = 85; /* .lib section in a.out corrupted */
    int ELIBMAX = 86; /* Attempting to link in too many libs */
    int ELIBEXEC = 87; /* Attempting to exec a shared library */
    int ENOSYS = 88; /* Function not implemented */
    int ENMFILE = 89; /* No more files */
    int ENOTEMPTY = 90; /* Directory not empty */
    int ENAMETOOLONG = 91; /* File or path name too long */
    int ELOOP = 92; /* Too many symbolic links */
    int EOPNOTSUPP = 95; /* Operation not supported on transport endpoint */
    int EPFNOSUPPORT = 96; /* Protocol family not supported */
    int ECONNRESET = 104; /* Connection reset by peer */
    int ENOBUFS = 105; /* No buffer space available */
    int EAFNOSUPPORT = 106; /* Address family not supported by protocol family */
    int EPROTOTYPE = 107; /* Protocol wrong type for socket */
    int ENOTSOCK = 108; /* Socket operation on non-socket */
    int ENOPROTOOPT = 109; /* Protocol not available */
    int ESHUTDOWN = 110; /* Can't send after socket shutdown */
    int ECONNREFUSED = 111; /* Connection refused */
    int EADDRINUSE = 112; /* Address already in use */
    int ECONNABORTED = 113; /* Connection aborted */
    int ENETUNREACH = 114; /* Network is unreachable */
    int ENETDOWN = 115; /* Network interface is not configured */
    int ETIMEDOUT = 116; /* Connection timed out */
    int EHOSTDOWN = 117; /* Host is down */
    int EHOSTUNREACH = 118; /* Host is unreachable */
    int EINPROGRESS = 119; /* Connection already in progress */
    int EALREADY = 120; /* Socket already connected */
    int EDESTADDRREQ = 121; /* Destination address required */
    int EMSGSIZE = 122; /* Message too long */
    int EPROTONOSUPPORT = 123; /* Unknown protocol */
    int ESOCKTNOSUPPORT = 124; /* Socket type not supported */
    int EADDRNOTAVAIL = 125; /* Address not available */
    int ENETRESET = 126;
    int EISCONN = 127; /* Socket is already connected */
    int ENOTCONN = 128; /* Socket is not connected */
    int ETOOMANYREFS = 129;
    int EPROCLIM = 130;
    int EUSERS = 131;
    int EDQUOT = 132;
    int ESTALE = 133;
    int ENOTSUP = 134; /* Not supported */
    int ENOMEDIUM = 135; /* No medium (in tape drive) */
    int ENOSHARE = 136; /* No such host or network path */
    int ECASECLASH = 137; /* Filename exists with different case */
    int EILSEQ = 138;
    int EOVERFLOW = 139; /* Value too large for defined data type */
    int __ELASTERROR = 2000; /* Users can add values starting here */
    int F_OK = 0;
    int R_OK = 4;
    int W_OK = 2;
    int X_OK = 1;
    int SEEK_SET = 0;
    int SEEK_CUR = 1;
    int SEEK_END = 2;
    int STDIN_FILENO = 0; /* standard input file descriptor */
    int STDOUT_FILENO = 1; /* standard output file descriptor */
    int STDERR_FILENO = 2; /* standard error file descriptor */
    int _SC_ARG_MAX = 0;
    int _SC_CHILD_MAX = 1;
    int _SC_CLK_TCK = 2;
    int _SC_NGROUPS_MAX = 3;
    int _SC_OPEN_MAX = 4;
    int _SC_JOB_CONTROL = 5;
    int _SC_SAVED_IDS = 6;
    int _SC_VERSION = 7;
    int _SC_PAGESIZE = 8;
    int _SC_NPROCESSORS_CONF = 9;
    int _SC_NPROCESSORS_ONLN = 10;
    int _SC_PHYS_PAGES = 11;
    int _SC_AVPHYS_PAGES = 12;
    int _SC_MQ_OPEN_MAX = 13;
    int _SC_MQ_PRIO_MAX = 14;
    int _SC_RTSIG_MAX = 15;
    int _SC_SEM_NSEMS_MAX = 16;
    int _SC_SEM_VALUE_MAX = 17;
    int _SC_SIGQUEUE_MAX = 18;
    int _SC_TIMER_MAX = 19;
    int _SC_TZNAME_MAX = 20;
    int _SC_ASYNCHRONOUS_IO = 21;
    int _SC_FSYNC = 22;
    int _SC_MAPPED_FILES = 23;
    int _SC_MEMLOCK = 24;
    int _SC_MEMLOCK_RANGE = 25;
    int _SC_MEMORY_PROTECTION = 26;
    int _SC_MESSAGE_PASSING = 27;
    int _SC_PRIORITIZED_IO = 28;
    int _SC_REALTIME_SIGNALS = 29;
    int _SC_SEMAPHORES = 30;
    int _SC_SHARED_MEMORY_OBJECTS = 31;
    int _SC_SYNCHRONIZED_IO = 32;
    int _SC_TIMERS = 33;
    int _SC_AIO_LISTIO_MAX = 34;
    int _SC_AIO_MAX = 35;
    int _SC_AIO_PRIO_DELTA_MAX = 36;
    int _SC_DELAYTIMER_MAX = 37;
    int _SC_THREAD_KEYS_MAX = 38;
    int _SC_THREAD_STACK_MIN = 39;
    int _SC_THREAD_THREADS_MAX = 40;
    int _SC_TTY_NAME_MAX = 41;
    int _SC_THREADS = 42;
    int _SC_THREAD_ATTR_STACKADDR = 43;
    int _SC_THREAD_ATTR_STACKSIZE = 44;
    int _SC_THREAD_PRIORITY_SCHEDULING = 45;
    int _SC_THREAD_PRIO_INHERIT = 46;
    int _SC_THREAD_PRIO_PROTECT = 47;
    int _SC_THREAD_PROCESS_SHARED = 48;
    int _SC_THREAD_SAFE_FUNCTIONS = 49;
    int _SC_GETGR_R_SIZE_MAX = 50;
    int _SC_GETPW_R_SIZE_MAX = 51;
    int _SC_LOGIN_NAME_MAX = 52;
    int _SC_THREAD_DESTRUCTOR_ITERATIONS = 53;
    int _SC_STREAM_MAX = 100;
    int _SC_PRIORITY_SCHEDULING = 101;
    int _PC_LINK_MAX = 0;
    int _PC_MAX_CANON = 1;
    int _PC_MAX_INPUT = 2;
    int _PC_NAME_MAX = 3;
    int _PC_PATH_MAX = 4;
    int _PC_PIPE_BUF = 5;
    int _PC_CHOWN_RESTRICTED = 6;
    int _PC_NO_TRUNC = 7;
    int _PC_VDISABLE = 8;
    int _PC_ASYNC_IO = 9;
    int _PC_PRIO_IO = 10;
    int _PC_SYNC_IO = 11;
    int _PC_POSIX_PERMISSIONS = 90;
    int _PC_POSIX_SECURITY = 91;
    int MAXPATHLEN = 1024;
    int ARG_MAX = 65536; /* max bytes for an exec function */
    int CHILD_MAX = 40; /* max simultaneous processes */
    int LINK_MAX = 32767; /* max file link count */
    int MAX_CANON = 255; /* max bytes in term canon input line */
    int MAX_INPUT = 255; /* max bytes in terminal input */
    int NAME_MAX = 255; /* max bytes in a file name */
    int NGROUPS_MAX = 16; /* max supplemental group id's */
    int OPEN_MAX = 64; /* max open files per process */
    int PATH_MAX = 1024; /* max bytes in pathname */
    int PIPE_BUF = 512; /* max bytes for atomic pipe writes */
    int IOV_MAX = 1024; /* max elements in i/o vector */
    int BC_BASE_MAX = 99; /* max ibase/obase values in bc(1) */
    int BC_DIM_MAX = 2048; /* max array elements in bc(1) */
    int BC_SCALE_MAX = 99; /* max scale value in bc(1) */
    int BC_STRING_MAX = 1000; /* max const string length in bc(1) */
    int COLL_WEIGHTS_MAX = 0; /* max weights for order keyword */
    int EXPR_NEST_MAX = 32; /* max expressions nested in expr(1) */
    int LINE_MAX = 2048; /* max bytes in an input line */
    int RE_DUP_MAX = 255; /* max RE's in interval notation */
    int CTL_MAXNAME = 12;
    int CTL_UNSPEC = 0; /* unused */
    int CTL_KERN = 1; /* "high kernel": proc, limits */
    int CTL_VM = 2; /* virtual memory */
    int CTL_VFS = 3; /* file system, mount type is next */
    int CTL_NET = 4; /* network, see socket.h */
    int CTL_DEBUG = 5; /* debugging parameters */
    int CTL_HW = 6; /* generic cpu/io */
    int CTL_MACHDEP = 7; /* machine dependent */
    int CTL_USER = 8; /* user-level */
    int CTL_P1003_1B = 9; /* POSIX 1003.1B */
    int CTL_MAXID = 10; /* number of valid top-level ids */
    int KERN_OSTYPE = 1; /* string: system version */
    int KERN_OSRELEASE = 2; /* string: system release */
    int KERN_OSREV = 3; /* int: system revision */
    int KERN_VERSION = 4; /* string: compile time info */
    int KERN_MAXVNODES = 5; /* int: max vnodes */
    int KERN_MAXPROC = 6; /* int: max processes */
    int KERN_MAXFILES = 7; /* int: max open files */
    int KERN_ARGMAX = 8; /* int: max arguments to exec */
    int KERN_SECURELVL = 9; /* int: system security level */
    int KERN_HOSTNAME = 10; /* string: hostname */
    int KERN_HOSTID = 11; /* int: host identifier */
    int KERN_CLOCKRATE = 12; /* struct: struct clockrate */
    int KERN_VNODE = 13; /* struct: vnode structures */
    int KERN_PROC = 14; /* struct: process entries */
    int KERN_FILE = 15; /* struct: file entries */
    int KERN_PROF = 16; /* node: kernel profiling info */
    int KERN_POSIX1 = 17; /* int: POSIX.1 version */
    int KERN_NGROUPS = 18; /* int: # of supplemental group ids */
    int KERN_JOB_CONTROL = 19; /* int: is job control available */
    int KERN_SAVED_IDS = 20; /* int: saved set-user/group-ID */
    int KERN_BOOTTIME = 21; /* struct: time kernel was booted */
    int KERN_NISDOMAINNAME = 22; /* string: YP domain name */
    int KERN_UPDATEINTERVAL = 23; /* int: update process sleep time */
    int KERN_OSRELDATE = 24; /* int: OS release date */
    int KERN_NTP_PLL = 25; /* node: NTP PLL control */
    int KERN_BOOTFILE = 26; /* string: name of booted kernel */
    int KERN_MAXFILESPERPROC = 27; /* int: max open files per proc */
    int KERN_MAXPROCPERUID = 28; /* int: max processes per uid */
    int KERN_DUMPDEV = 29; /* dev_t: device to dump on */
    int KERN_IPC = 30; /* node: anything related to IPC */
    int KERN_DUMMY = 31; /* unused */
    int KERN_PS_STRINGS = 32; /* int: address of PS_STRINGS */
    int KERN_USRSTACK = 33; /* int: address of USRSTACK */
    int KERN_LOGSIGEXIT = 34; /* int: do we log sigexit procs? */
    int KERN_MAXID = 35; /* number of valid kern ids */
    int KERN_PROC_ALL = 0; /* everything */
    int KERN_PROC_PID = 1; /* by process id */
    int KERN_PROC_PGRP = 2; /* by process group id */
    int KERN_PROC_SESSION = 3; /* by session of pid */
    int KERN_PROC_TTY = 4; /* by controlling tty */
    int KERN_PROC_UID = 5; /* by effective uid */
    int KERN_PROC_RUID = 6; /* by real uid */
    int KERN_PROC_ARGS = 7; /* get/set arguments/proctitle */
    int KIPC_MAXSOCKBUF = 1; /* int: max size of a socket buffer */
    int KIPC_SOCKBUF_WASTE = 2; /* int: wastage factor in sockbuf */
    int KIPC_SOMAXCONN = 3; /* int: max length of connection q */
    int KIPC_MAX_LINKHDR = 4; /* int: max length of link header */
    int KIPC_MAX_PROTOHDR = 5; /* int: max length of network header */
    int KIPC_MAX_HDR = 6; /* int: max total length of headers */
    int KIPC_MAX_DATALEN = 7; /* int: max length of data? */
    int KIPC_MBSTAT = 8; /* struct: mbuf usage statistics */
    int KIPC_NMBCLUSTERS = 9; /* int: maximum mbuf clusters */
    int HW_MACHINE = 1; /* string: machine class */
    int HW_MODEL = 2; /* string: specific machine model */
    int HW_NCPU = 3; /* int: number of cpus */
    int HW_BYTEORDER = 4; /* int: machine byte order */
    int HW_PHYSMEM = 5; /* int: total memory */
    int HW_USERMEM = 6; /* int: non-kernel memory */
    int HW_PAGESIZE = 7; /* int: software page size */
    int HW_DISKNAMES = 8; /* strings: disk drive names */
    int HW_DISKSTATS = 9; /* struct: diskstats[] */
    int HW_FLOATINGPT = 10; /* int: has HW floating point? */
    int HW_MACHINE_ARCH = 11; /* string: machine architecture */
    int HW_MAXID = 12; /* number of valid hw ids */
    int USER_CS_PATH = 1; /* string: _CS_PATH */
    int USER_BC_BASE_MAX = 2; /* int: BC_BASE_MAX */
    int USER_BC_DIM_MAX = 3; /* int: BC_DIM_MAX */
    int USER_BC_SCALE_MAX = 4; /* int: BC_SCALE_MAX */
    int USER_BC_STRING_MAX = 5; /* int: BC_STRING_MAX */
    int USER_COLL_WEIGHTS_MAX = 6; /* int: COLL_WEIGHTS_MAX */
    int USER_EXPR_NEST_MAX = 7; /* int: EXPR_NEST_MAX */
    int USER_LINE_MAX = 8; /* int: LINE_MAX */
    int USER_RE_DUP_MAX = 9; /* int: RE_DUP_MAX */
    int USER_POSIX2_VERSION = 10; /* int: POSIX2_VERSION */
    int USER_POSIX2_C_BIND = 11; /* int: POSIX2_C_BIND */
    int USER_POSIX2_C_DEV = 12; /* int: POSIX2_C_DEV */
    int USER_POSIX2_CHAR_TERM = 13; /* int: POSIX2_CHAR_TERM */
    int USER_POSIX2_FORT_DEV = 14; /* int: POSIX2_FORT_DEV */
    int USER_POSIX2_FORT_RUN = 15; /* int: POSIX2_FORT_RUN */
    int USER_POSIX2_LOCALEDEF = 16; /* int: POSIX2_LOCALEDEF */
    int USER_POSIX2_SW_DEV = 17; /* int: POSIX2_SW_DEV */
    int USER_POSIX2_UPE = 18; /* int: POSIX2_UPE */
    int USER_STREAM_MAX = 19; /* int: POSIX2_STREAM_MAX */
    int USER_TZNAME_MAX = 20; /* int: POSIX2_TZNAME_MAX */
    int USER_MAXID = 21; /* number of valid user ids */
    int CTL_P1003_1B_ASYNCHRONOUS_IO = 1; /* boolean */
    int CTL_P1003_1B_MAPPED_FILES = 2; /* boolean */
    int CTL_P1003_1B_MEMLOCK = 3; /* boolean */
    int CTL_P1003_1B_MEMLOCK_RANGE = 4; /* boolean */
    int CTL_P1003_1B_MEMORY_PROTECTION = 5; /* boolean */
    int CTL_P1003_1B_MESSAGE_PASSING = 6; /* boolean */
    int CTL_P1003_1B_PRIORITIZED_IO = 7; /* boolean */
    int CTL_P1003_1B_PRIORITY_SCHEDULING = 8; /* boolean */
    int CTL_P1003_1B_REALTIME_SIGNALS = 9; /* boolean */
    int CTL_P1003_1B_SEMAPHORES = 10; /* boolean */
    int CTL_P1003_1B_FSYNC = 11; /* boolean */
    int CTL_P1003_1B_SHARED_MEMORY_OBJECTS = 12; /* boolean */
    int CTL_P1003_1B_SYNCHRONIZED_IO = 13; /* boolean */
    int CTL_P1003_1B_TIMERS = 14; /* boolean */
    int CTL_P1003_1B_AIO_LISTIO_MAX = 15; /* int */
    int CTL_P1003_1B_AIO_MAX = 16; /* int */
    int CTL_P1003_1B_AIO_PRIO_DELTA_MAX = 17; /* int */
    int CTL_P1003_1B_DELAYTIMER_MAX = 18; /* int */
    int CTL_P1003_1B_MQ_OPEN_MAX = 19; /* int */
    int CTL_P1003_1B_PAGESIZE = 20; /* int */
    int CTL_P1003_1B_RTSIG_MAX = 21; /* int */
    int CTL_P1003_1B_SEM_NSEMS_MAX = 22; /* int */
    int CTL_P1003_1B_SEM_VALUE_MAX = 23; /* int */
    int CTL_P1003_1B_SIGQUEUE_MAX = 24; /* int */
    int CTL_P1003_1B_TIMER_MAX = 25; /* int */
    int CTL_P1003_1B_MAXID = 26;
    int F_UNLKSYS = 4;
    int F_CNVT = 12;
    int F_SETFD = 2;
    int F_SETFL = 4;
    int F_SETLK = 8;
    int F_SETOWN = 6;
    int F_RDLCK = 1;
    int F_WRLCK = 2;
    int F_SETLKW = 9;
    int F_GETFD = 1;
    int F_DUPFD = 0;
    int O_WRONLY = 1;
    int F_RSETLKW = 13;
    int O_RDWR = 2;
    int F_RGETLK = 10;
    int O_RDONLY = 0;
    int F_UNLCK = 3;
    int F_GETOWN = 5;
    int F_RSETLK = 11;
    int F_GETFL = 3;
    int F_GETLK = 7;
}
