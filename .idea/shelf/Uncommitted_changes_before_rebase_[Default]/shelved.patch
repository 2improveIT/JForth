Index: src/jforth/build.number
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#Build Number for ANT. Do not edit!\r\n#Fri Sep 25 02:29:02 CEST 2020\r\nbuild.number=1989\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/jforth/build.number	(revision e8c784871ce2d456652c5ac6d8716101cdc7690c)
+++ src/jforth/build.number	(date 1601858774848)
@@ -1,3 +1,3 @@
 #Build Number for ANT. Do not edit!
-#Fri Sep 25 02:29:02 CEST 2020
-build.number=1989
+#Mon Oct 05 02:46:14 CEST 2020
+build.number=2006
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ClientPropertiesManager\">\r\n    <properties class=\"javax.swing.AbstractButton\">\r\n      <property name=\"hideActionText\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JComponent\">\r\n      <property name=\"html.disable\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JEditorPane\">\r\n      <property name=\"JEditorPane.w3cLengthUnits\" class=\"java.lang.Boolean\" />\r\n      <property name=\"JEditorPane.honorDisplayProperties\" class=\"java.lang.Boolean\" />\r\n      <property name=\"charset\" class=\"java.lang.String\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JList\">\r\n      <property name=\"List.isFileList\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JPasswordField\">\r\n      <property name=\"JPasswordField.cutCopyAllowed\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JSlider\">\r\n      <property name=\"Slider.paintThumbArrowShape\" class=\"java.lang.Boolean\" />\r\n      <property name=\"JSlider.isFilled\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JTable\">\r\n      <property name=\"Table.isFileList\" class=\"java.lang.Boolean\" />\r\n      <property name=\"JTable.autoStartsEdit\" class=\"java.lang.Boolean\" />\r\n      <property name=\"terminateEditOnFocusLost\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JToolBar\">\r\n      <property name=\"JToolBar.isRollover\" class=\"java.lang.Boolean\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.JTree\">\r\n      <property name=\"JTree.lineStyle\" class=\"java.lang.String\" />\r\n    </properties>\r\n    <properties class=\"javax.swing.text.JTextComponent\">\r\n      <property name=\"caretAspectRatio\" class=\"java.lang.Double\" />\r\n      <property name=\"caretWidth\" class=\"java.lang.Integer\" />\r\n    </properties>\r\n  </component>\r\n  <component name=\"DevPartner.ProjectProperties\">\r\n    <option name=\"dpjConfigurationName\" value=\"misc\" />\r\n  </component>\r\n  <component name=\"FrameworkDetectionExcludesConfiguration\" detection-enabled=\"false\" />\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_9\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision e8c784871ce2d456652c5ac6d8716101cdc7690c)
+++ .idea/misc.xml	(date 1601753496623)
@@ -42,7 +42,7 @@
     <option name="dpjConfigurationName" value="misc" />
   </component>
   <component name="FrameworkDetectionExcludesConfiguration" detection-enabled="false" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_9" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
Index: src/jforth/audio/WaveTools.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package jforth.audio;\r\n\r\nimport jforth.Utilities;\r\n\r\nimport javax.sound.sampled.*;\r\nimport java.io.*;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\n/**\r\n * from here: ftp://sccn.ucsd.edu/pub/virtualmedia/AePlayWave.java\r\n */\r\n\r\npublic class WaveTools\r\n{\r\n    private static final Charset thisCharset = StandardCharsets.ISO_8859_1;\r\n\r\n//    /**\r\n//     * Play wave file from disk\r\n//     * @param wavfile a disk file\r\n//     */\r\n//    public static void playSound (String wavfile)\r\n//    {\r\n//        try\r\n//        {\r\n//            File soundFile = new File(wavfile);\r\n//            InputStream inp = new BufferedInputStream(new FileInputStream(soundFile));\r\n//            playSound(inp);\r\n//        }\r\n//        catch (Exception e)\r\n//        {\r\n//            e.printStackTrace();\r\n//        }\r\n//    }\r\n\r\n//    /**\r\n//     * Play wave from an array\r\n//     * @param data Array containing wav data+header\r\n//     */\r\n//    public static Clip playSound (byte[] data)\r\n//    {\r\n//        try\r\n//        {\r\n//            InputStream inp  = new BufferedInputStream(new ByteArrayInputStream (data));\r\n//            return playSound(inp);\r\n//        }\r\n//        catch (Exception e)\r\n//        {\r\n//            return null;\r\n//        }\r\n//    }\r\n//\r\n//    /**\r\n//     * Play wave from Stream\r\n//     * @param inp Stream containing wave data + header\r\n//     */\r\n//    public static Clip playSound (InputStream inp)\r\n//    {\r\n//        try\r\n//        {\r\n//            AudioInputStream audioIn = AudioSystem.getAudioInputStream(inp);\r\n//            Clip clip = AudioSystem.getClip();\r\n//            clip.open(audioIn);\r\n//            clip.start();\r\n//            return clip;\r\n//        }\r\n//        catch (Exception e)\r\n//        {\r\n//            return null;\r\n//        }\r\n//    }\r\n\r\n    /**\r\n     * Run the SAM module and convert a text to speech data\r\n     * @param words Text to be spoken\r\n     * @return String containing wave file\r\n     * @throws Exception if smth gone wrong\r\n     */\r\n    public static String SAMtoWaveString (String words) throws Exception\r\n    {\r\n        words = words.replace('-','_');\r\n        String res = Utilities.extractResource(\"sam.exe\");\r\n        Process process = new ProcessBuilder(\r\n                res, \"-stdout\", \"dummy\", words)\r\n                .start();\r\n        InputStream is = process.getInputStream();\r\n\r\n        StringBuilder textBuilder = new StringBuilder();\r\n        try (Reader reader = new BufferedReader(new InputStreamReader\r\n                (is, thisCharset)))\r\n        {\r\n            int c;\r\n            while ((c = reader.read()) != -1)\r\n            {\r\n                textBuilder.append((char) c);\r\n            }\r\n        }\r\n        is.close();\r\n        return textBuilder.toString();\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * Load wave file and start playing\r\n     * @param file the file object\r\n     * @return tha running clip\r\n     * @throws Exception if smth gone wrong\r\n     */\r\n    public static Clip playWave (File file, boolean cont) throws Exception\r\n    {\r\n        final Clip clip = (Clip) AudioSystem.getLine (new Line.Info (Clip.class));\r\n        clip.open (AudioSystem.getAudioInputStream (file));\r\n        if (cont)\r\n            clip.loop (Clip.LOOP_CONTINUOUSLY);\r\n        clip.start ();\r\n        return clip;\r\n    }\r\n\r\n    public static Clip playWave (byte[] data, boolean cont) throws Exception\r\n    {\r\n        final Clip clip = (Clip) AudioSystem.getLine (new Line.Info (Clip.class));\r\n        InputStream inp  = new BufferedInputStream(new ByteArrayInputStream (data));\r\n        clip.open (AudioSystem.getAudioInputStream (inp));\r\n        if (cont)\r\n            clip.loop (Clip.LOOP_CONTINUOUSLY);\r\n        clip.start ();\r\n        return clip;\r\n    }\r\n\r\n    /**\r\n     * Stop and close an audio clip\r\n     * @param clip the playing clip\r\n     */\r\n    public static void stopWave (Clip clip)\r\n    {\r\n        clip.stop ();\r\n        clip.close ();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/jforth/audio/WaveTools.java	(revision e8c784871ce2d456652c5ac6d8716101cdc7690c)
+++ src/jforth/audio/WaveTools.java	(date 1601858637618)
@@ -79,10 +79,11 @@
     public static String SAMtoWaveString (String words) throws Exception
     {
         words = words.replace('-','_');
-        String res = Utilities.extractResource("sam.exe");
-        Process process = new ProcessBuilder(
-                res, "-stdout", "dummy", words)
-                .start();
+        String res = Utilities.extractResource("sam.exe", false);
+        ProcessBuilder pb = new ProcessBuilder(
+                res, "-stdout", "dummy", words);
+        Process process = pb.start();
+        //Thread.sleep (3000);
         InputStream is = process.getInputStream();
 
         StringBuilder textBuilder = new StringBuilder();
Index: src/jforth/Utilities.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package jforth;\r\n\r\nimport org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\r\nimport org.apache.commons.math3.complex.Complex;\r\nimport org.apache.commons.math3.fraction.Fraction;\r\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\r\nimport org.apache.commons.math3.linear.BlockRealMatrix;\r\nimport org.apache.commons.math3.linear.MatrixUtils;\r\nimport tools.TwoFuncs;\r\n\r\nimport javax.sound.sampled.AudioSystem;\r\nimport javax.sound.sampled.Clip;\r\nimport javax.sound.sampled.Line;\r\nimport java.io.*;\r\nimport java.math.BigInteger;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.stream.Collectors;\r\n//import java.util.function.BiFunction;\r\n\r\n/**\r\n * Created by Administrator on 3/21/2017.\r\n */\r\npublic class Utilities\r\n{\r\n    private static final String BUILD_NUMBER = \"1988\";\r\n    private static final String BUILD_DATE = \"09/25/2020 02:29:02 AM\";\r\n\r\n    public static final String buildInfo = \"JForth, Build: \" + Utilities.BUILD_NUMBER + \", \" + Utilities.BUILD_DATE\r\n            + \" -- \" + System.getProperty (\"java.version\");\r\n\r\n\r\n    private static final char[] hexCode = \"0123456789ABCDEF\".toCharArray ();\r\n\r\n    public static String printHexBinary (byte[] data)\r\n    {\r\n        StringBuilder r = new StringBuilder (data.length * 2);\r\n        for (byte b : data)\r\n        {\r\n            r.append (hexCode[(b >> 4) & 0xF]);\r\n            r.append (hexCode[(b & 0xF)]);\r\n        }\r\n        return r.toString ();\r\n    }\r\n\r\n    public static int hexToBin (char ch)\r\n    {\r\n        if ('0' <= ch && ch <= '9')\r\n        {\r\n            return ch - '0';\r\n        }\r\n        if ('A' <= ch && ch <= 'F')\r\n        {\r\n            return ch - 'A' + 10;\r\n        }\r\n        if ('a' <= ch && ch <= 'f')\r\n        {\r\n            return ch - 'a' + 10;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public static byte[] parseHexBinary (String s)\r\n    {\r\n        final int len = s.length ();\r\n\r\n        // \"111\" is not a valid hex encoding.\r\n        if (len % 2 != 0)\r\n        {\r\n            throw new IllegalArgumentException (\"hexBinary needs to be even-length: \" + s);\r\n        }\r\n\r\n        byte[] out = new byte[len / 2];\r\n\r\n        for (int i = 0; i < len; i += 2)\r\n        {\r\n            int h = hexToBin (s.charAt (i));\r\n            int l = hexToBin (s.charAt (i + 1));\r\n            if (h == -1 || l == -1)\r\n            {\r\n                throw new IllegalArgumentException (\"contains illegal character for hexBinary: \" + s);\r\n            }\r\n\r\n            out[i / 2] = (byte) (h * 16 + l);\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    public static BigInteger factorial (long n)\r\n    {\r\n        BigInteger fact = BigInteger.valueOf (1);\r\n        for (int i = 1; i <= n; i++)\r\n        {\r\n            fact = fact.multiply (BigInteger.valueOf (i));\r\n        }\r\n        return fact;\r\n    }\r\n\r\n    public static BigInteger fib (long n)\r\n    {\r\n        BigInteger a = BigInteger.valueOf (0);\r\n        BigInteger b = BigInteger.valueOf (1);\r\n        BigInteger c;\r\n        for (long j = 2; j <= n; j++)\r\n        {\r\n            c = a.add (b);\r\n            a = b;\r\n            b = c;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Makes seconds from hh:mm:ss format\r\n     *\r\n     * @param in input string\r\n     * @return value in seconds\r\n     */\r\n    public static Long parseTimer (String in)\r\n    {\r\n        String[] parts = in.split (\":\");\r\n        if (parts.length != 3)\r\n        {\r\n            return null;\r\n        }\r\n        try\r\n        {\r\n            int h = Integer.parseInt (parts[0]);\r\n            if (h < 0)\r\n            {\r\n                return null;\r\n            }\r\n            int m = Integer.parseInt (parts[1]);\r\n            if (m < 0 || m > 59)\r\n            {\r\n                return null;\r\n            }\r\n            int s = Integer.parseInt (parts[2]);\r\n            if (s < 0 || s > 59)\r\n            {\r\n                return null;\r\n            }\r\n            return (long) (3600 * h + 60 * m + s);\r\n        } catch (NumberFormatException e)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static String toTimeView (Long in)\r\n    {\r\n        int h = (int) (in / 3600);\r\n        int s = (int) (in % 3600);\r\n        int m = s / 60;\r\n        s %= 60;\r\n        return String.format (\"%d:%02d:%02d\", h, m, s);\r\n    }\r\n\r\n    public static byte[] toRawByteArray (String in)\r\n    {\r\n        char[] chars = in.toCharArray ();\r\n        byte[] bytes = new byte[chars.length * 2];\r\n        for (int i = 0; i < chars.length; i++)\r\n        {\r\n            bytes[i * 2] = (byte) (chars[i] >> 8);\r\n            bytes[i * 2 + 1] = (byte) chars[i];\r\n        }\r\n        return bytes;\r\n    }\r\n\r\n    public static char[] fromRawByteArray (byte[] bytes)\r\n    {\r\n        char[] chars2 = new char[bytes.length / 2];\r\n        for (int i = 0; i < chars2.length; i++)\r\n        {\r\n            chars2[i] = (char) ((bytes[i * 2] << 8) + (bytes[i * 2 + 1] & 0xFF));\r\n        }\r\n        return chars2;\r\n    }\r\n\r\n    public static void terminateSoon (int delay)\r\n    {\r\n        new Thread (() ->\r\n        {\r\n            try\r\n            {\r\n                Thread.sleep (delay);\r\n            } catch (InterruptedException e)\r\n            {\r\n                e.printStackTrace ();\r\n            }\r\n            System.exit (0);\r\n        }).start ();\r\n    }\r\n\r\n    public static String formatDouble (Double d)\r\n    {\r\n        String outstr = Double.toString (d);\r\n        if (outstr.endsWith (\".0\"))\r\n        {\r\n            outstr = outstr.substring (0, outstr.length () - 2);\r\n        }\r\n        if (outstr.equals (\"-0\"))\r\n        {\r\n            outstr = \"0\";\r\n        }\r\n        return outstr;\r\n    }\r\n\r\n    public static String formatComplex (Complex c)\r\n    {\r\n        String re = formatDouble (c.getReal ());\r\n        String im = formatDouble (c.getImaginary ());\r\n        if (im.equals (\"0\"))\r\n        {\r\n            return re;\r\n        }\r\n        if (re.equals (\"0\"))\r\n        {\r\n            return im + \"i\";\r\n        }\r\n        if (im.charAt (0) == '-')\r\n        {\r\n            return re + im + \"i\";\r\n        }\r\n        return re + \"+\" + im + \"i\";\r\n    }\r\n\r\n    static Complex parseOnlyImaginary (String in)\r\n    {\r\n        int sign = in.charAt (0) == '-' ? -1 : 1;\r\n        if (sign == -1)\r\n        {\r\n            in = in.substring (1);\r\n        }\r\n        if (in.charAt (in.length () - 1) != 'i')\r\n        {\r\n            return null;\r\n        }\r\n        String num = in.substring (0, in.length () - 1);\r\n        try\r\n        {\r\n            int inum = Integer.parseInt (num);\r\n            return new Complex (0, inum * sign);\r\n        } catch (NumberFormatException e)\r\n        {\r\n            /* ignored */\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static Complex parseComplex (String in, int base)\r\n    {\r\n        if (base != 10)\r\n        {\r\n            return null;\r\n        }\r\n        Complex cpl = parseOnlyImaginary (in);\r\n        if (cpl != null)\r\n        {\r\n            return cpl;\r\n        }\r\n        boolean negfirst = false;\r\n        if (in.startsWith (\"-\"))\r\n        {\r\n            in = in.substring (1);\r\n            negfirst = true;\r\n        }\r\n        String[] parts = in.split (\"(-)|(\\\\+)\");\r\n        if (parts.length != 2)\r\n        {\r\n            return null;\r\n        }\r\n        if (!parts[1].endsWith (\"i\"))\r\n        {\r\n            return null;\r\n        }\r\n        parts[1] = parts[1].substring (0, parts[1].length () - 1);\r\n        if (negfirst)\r\n        {\r\n            parts[0] = \"-\" + parts[0];\r\n        }\r\n        if (in.substring (1).contains (\"-\"))\r\n        {\r\n            parts[1] = \"-\" + parts[1];\r\n        }\r\n        return new Complex (Double.parseDouble (parts[0]), Double.parseDouble (parts[1]));\r\n    }\r\n\r\n    static Fraction parseFraction (String in, int base)\r\n    {\r\n        if (base != 10)\r\n        {\r\n            return null;\r\n        }\r\n        String[] parts = in.split (\"/\");\r\n        if (parts.length != 2)\r\n        {\r\n            return null;\r\n        }\r\n        try\r\n        {\r\n            return new Fraction (Integer.parseInt (parts[0]), Integer.parseInt (parts[1]));\r\n        } catch (NumberFormatException e)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static String formatFraction (Fraction f)\r\n    {\r\n        if (f.getDenominator () == 1)\r\n        {\r\n            return \"\" + f.getNumerator ();\r\n        }\r\n        return f.getNumerator () + \"/\" + f.getDenominator ();\r\n    }\r\n\r\n    public static Object deepCopy (Object o)\r\n    {\r\n        try\r\n        {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            new ObjectOutputStream(baos).writeObject(o);\r\n\r\n            ByteArrayInputStream bais =\r\n                    new ByteArrayInputStream(baos.toByteArray());\r\n\r\n            return new ObjectInputStream(bais).readObject();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static String removeTrailingZero (double v)\r\n    {\r\n        return removeTrailingZero (v, false);\r\n    }\r\n\r\n    public static String removeTrailingZero (double v, boolean round)\r\n    {\r\n        String str;\r\n        if (round)\r\n        {\r\n            v = Math.round (10000.0 * v) / 10000.0;\r\n        }\r\n        str = \"\" + v;\r\n        if (str.endsWith (\".0\"))\r\n        {\r\n            return str.substring (0, str.length () - 2);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    public static BigInteger parseBigInt (String word, int base)\r\n    {\r\n        try\r\n        {\r\n            if (word.endsWith (\"L\"))\r\n            {\r\n                word = word.substring (0, word.length () - 1);\r\n                return new BigInteger (word, base);\r\n            }\r\n            return null;\r\n        } catch (Exception ignored)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static Long parseBinary (String in)\r\n    {\r\n        int sign = 1;\r\n        if (in.charAt (0) == '-')\r\n        {\r\n            sign = -1;\r\n            in = in.substring (1);\r\n        }\r\n        if (in.startsWith (\"0b\"))\r\n        {\r\n            in = in.substring (2);\r\n            try\r\n            {\r\n                return Long.parseLong (in, 2) * sign;\r\n            } catch (NumberFormatException e)\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static Long parseLong (String word, int base)\r\n    {\r\n        try\r\n        {\r\n            return Long.parseLong (word, base);\r\n        } catch (NumberFormatException ignored)\r\n        {\r\n            try\r\n            {\r\n                return Long.decode (word);\r\n            } catch (NumberFormatException e)\r\n            {\r\n                Long ll = parseBinary (word);\r\n                if (ll == null)\r\n                {\r\n                    return parseTimer (word);\r\n                }\r\n                return ll;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Double parseDouble (String word, int base)\r\n    {\r\n        if (base != 10)\r\n        {\r\n            return null;\r\n        }\r\n        try\r\n        {\r\n            return Double.parseDouble (word);\r\n        } catch (Exception ignored)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    public static List<String> splitEqually (String text, int size)\r\n    {\r\n        try\r\n        {\r\n            List<String> ret = new ArrayList<> ((text.length () + size - 1) / size);\r\n            for (int start = 0; start < text.length (); start += size)\r\n            {\r\n                ret.add (text.substring (start, Math.min (text.length (), start + size)));\r\n            }\r\n            return ret;\r\n        } catch (Exception unused)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static List<DoubleSequence> splitEqually (DoubleSequence text, int size)\r\n    {\r\n        try\r\n        {\r\n            List<DoubleSequence> ret = new ArrayList<> ((text.length () + size - 1) / size);\r\n            for (int start = 0; start < text.length (); start += size)\r\n            {\r\n                ret.add (text.subList (start, Math.min (text.length (), start + size)));\r\n            }\r\n            return ret;\r\n        } catch (Exception unused)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static String parseString (String in)\r\n    {\r\n        if (in.length () < 2)\r\n        {\r\n            return null;\r\n        }\r\n        if (!in.startsWith (\"\\\"\"))\r\n        {\r\n            return null;\r\n        }\r\n        if (!in.endsWith (\"\\\"\"))\r\n        {\r\n            return null;\r\n        }\r\n        return in.substring (1, in.length () - 1);\r\n    }\r\n\r\n\r\n    public static String rotRight (String s, int a)\r\n    {\r\n        char[] array = s.toCharArray ();\r\n        try\r\n        {\r\n            char[] tmp = new char[a];\r\n            System.arraycopy (array, array.length - a, tmp, 0, a);\r\n            System.arraycopy (array, 0, array, a, array.length - a);\r\n            System.arraycopy (tmp, 0, array, 0, a);\r\n            return new String (array);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            return s;\r\n        }\r\n    }\r\n\r\n    public static String rotLeft (String s, int a)\r\n    {\r\n        return rotRight (s, s.length () - a);\r\n    }\r\n\r\n    public static byte[] rotRight (byte[] array, int a)\r\n    {\r\n        try\r\n        {\r\n            byte[] ret = new byte[array.length];\r\n            System.arraycopy (array, 0, ret, a, array.length - a);\r\n            System.arraycopy (array, array.length-a, ret, 0, a);\r\n            return ret;\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            return array;\r\n        }\r\n    }\r\n\r\n    public static byte[] rotLeft (byte[] array, int a)\r\n    {\r\n        return rotRight (array, array.length - a);\r\n    }\r\n\r\n    public static double readDouble (OStack dStack) throws Exception\r\n    {\r\n        Object o = dStack.pop ();\r\n        return getDouble (o);\r\n    }\r\n\r\n    static public boolean canBeDouble (Object o1)\r\n    {\r\n        if (o1 instanceof BigInteger)\r\n        {\r\n            return true;\r\n        }\r\n        if (o1 instanceof Double)\r\n        {\r\n            return true;\r\n        }\r\n        if (o1 instanceof Long)\r\n        {\r\n            return true;\r\n        }\r\n        if (o1 instanceof Fraction)\r\n        {\r\n            return true;\r\n        }\r\n        return o1 instanceof Complex;\r\n    }\r\n\r\n    static public Double getDouble (Object o1) throws Exception\r\n    {\r\n        if (o1 instanceof BigInteger)\r\n        {\r\n            return ((BigInteger) o1).doubleValue ();\r\n        }\r\n        if (o1 instanceof Double)\r\n        {\r\n            return (Double) o1;\r\n        }\r\n        if (o1 instanceof Long)\r\n        {\r\n            return ((Long) o1).doubleValue ();\r\n        }\r\n        if (o1 instanceof Fraction)\r\n        {\r\n            double denom = ((Fraction) o1).getDenominator ();\r\n            double nume = ((Fraction) o1).getNumerator ();\r\n            return nume / denom;\r\n        }\r\n        if (o1 instanceof Complex)\r\n        {\r\n            Complex c = (Complex) o1;\r\n            if (c.getImaginary () == 0.0)\r\n            {\r\n                return c.getReal ();\r\n            }\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static long readLong (OStack dStack) throws Exception\r\n    {\r\n        return getLong (dStack.pop ());\r\n    }\r\n\r\n    public static FileInputStream readFileInputStream (OStack dStack)\r\n    {\r\n        return (FileInputStream) dStack.pop ();\r\n    }\r\n\r\n\r\n    public static long getLong (Object o) throws Exception\r\n    {\r\n        if (o instanceof BigInteger)\r\n        {\r\n            return ((BigInteger) o).longValue ();\r\n        }\r\n        if (o instanceof Double)\r\n        {\r\n            return ((Double) o).longValue ();\r\n        }\r\n        if (o instanceof Long)\r\n        {\r\n            return (Long) o;\r\n        }\r\n        if (o instanceof Fraction)\r\n        {\r\n            int denom = ((Fraction) o).getDenominator ();\r\n            int nume = ((Fraction) o).getNumerator ();\r\n            if (nume % denom == 0)\r\n            {\r\n                return nume / denom;\r\n            }\r\n        }\r\n        if (o instanceof Complex)\r\n        {\r\n            Complex c = (Complex) o;\r\n            return ((Double) c.getReal ()).longValue ();\r\n        }\r\n        throw new Exception (\"Wrong or no Type on Stack\");\r\n    }\r\n\r\n    public static BigInteger readBig (OStack dStack) throws Exception\r\n    {\r\n        Object o = dStack.pop ();\r\n        return getBig (o);\r\n    }\r\n\r\n    public static FileBlob readBlob (OStack stack) throws Exception\r\n    {\r\n        return getBlob (stack.pop ());\r\n\r\n    }\r\n\r\n    public static FileBlob getBlob (Object o) throws Exception\r\n    {\r\n        if (o instanceof FileBlob)\r\n        {\r\n            return (FileBlob) o;\r\n        }\r\n        throw new Exception (\"no blob\");\r\n    }\r\n\r\n\r\n    private static BigInteger getBig (Object o1) throws Exception\r\n    {\r\n        if (o1 instanceof BigInteger)\r\n        {\r\n            return (BigInteger) o1;\r\n        }\r\n        if (o1 instanceof Long)\r\n        {\r\n            return BigInteger.valueOf ((Long) o1);\r\n        }\r\n        if (o1 instanceof Double)\r\n        {\r\n            return BigInteger.valueOf (((Double) o1).longValue ());\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static String readStringOrNull (OStack dstack)\r\n    {\r\n        try\r\n        {\r\n            return readString (dstack);\r\n        } catch (Exception e)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static String readString (OStack dStack) throws Exception\r\n    {\r\n        Object o = dStack.pop ();\r\n        if (o instanceof String)\r\n        {\r\n            return StringEscape.unescape ((String) o);\r\n        }\r\n        if (o instanceof Long)\r\n        {\r\n            return o.toString ();\r\n        }\r\n        if (o instanceof Double)\r\n        {\r\n            return o.toString ();\r\n        }\r\n        if (o instanceof BigInteger)\r\n        {\r\n            return o.toString ();\r\n        }\r\n        if (o instanceof FileBlob)\r\n        {\r\n            return ((FileBlob) o).asString ();\r\n        }\r\n        throw new Exception (\"Wrong or no Type on Stack\");\r\n    }\r\n\r\n    public static Complex readComplex (OStack dStack) throws Exception\r\n    {\r\n        return getComplex (dStack.pop ());\r\n    }\r\n\r\n    private static Complex getComplex (Object o1) throws Exception\r\n    {\r\n        if (o1 instanceof Complex)\r\n        {\r\n            return (Complex) o1;\r\n        }\r\n        if (o1 instanceof Long)\r\n        {\r\n            return new Complex ((Long) o1);\r\n        }\r\n        else if (o1 instanceof Double)\r\n        {\r\n            return new Complex ((Double) o1);\r\n        }\r\n        else if (o1 instanceof Fraction)\r\n        {\r\n            Fraction fr = (Fraction) o1;\r\n            return new Complex ((double) fr.getNumerator () / (double) fr.getDenominator ());\r\n        }\r\n        else if (o1 instanceof BigInteger)\r\n        {\r\n            return new Complex (((BigInteger) o1).longValue ());\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static double[] parseCSVtoDoubleArray (String in)\r\n    {\r\n        try\r\n        {\r\n            String[] vals = in.split (\",\");\r\n            double[] out = new double[vals.length];\r\n            for (int s = 0; s < vals.length; s++)\r\n            {\r\n                out[s] = Double.parseDouble (vals[s]);\r\n            }\r\n            return out;\r\n        } catch (NumberFormatException e)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static String removeBeginEnd (String in, char[] be, boolean mustHave)\r\n    {\r\n        if (in.charAt (0) == be[0] && in.charAt (in.length () - 1) == be[1])\r\n        {\r\n            return (in.substring (1, in.length () - 1));\r\n        }\r\n        if (mustHave)\r\n        {\r\n            return null;\r\n        }\r\n        return in;\r\n    }\r\n\r\n    public static String extractSequence (String in)\r\n    {\r\n        return removeBeginEnd (in, new char[]{'{', '}'}, true);\r\n    }\r\n\r\n    public static String extractStringBody (String in)\r\n    {\r\n        return removeBeginEnd (in, new char[]{'\\\"', '\\\"'}, false);\r\n    }\r\n\r\n    public static Vector3D readVector3D (OStack dStack) throws Exception\r\n    {\r\n        DoubleSequence ds = readDoubleSequence (dStack);\r\n        double i2;\r\n        if (ds.length () > 3 || ds.length () < 2)\r\n        {\r\n            throw new Exception (\"wrong size\");\r\n        }\r\n        if (ds.length () == 2)\r\n        {\r\n            i2 = 0;\r\n        }\r\n        else\r\n        {\r\n            i2 = ds.pick (2);\r\n        }\r\n        return new Vector3D (ds.pick (0), ds.pick (1), i2);\r\n    }\r\n\r\n    public static StringSequence readStringSequence (OStack dStack) throws Exception\r\n    {\r\n        return getStringSequence (dStack.pop ());\r\n    }\r\n\r\n    public static StringSequence getStringSequence (Object o)\r\n    {\r\n        if (o instanceof StringSequence)\r\n        {\r\n            return (StringSequence) o;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static DoubleSequence readDoubleSequence (OStack dStack) throws Exception\r\n    {\r\n        return getDoubleSequence (dStack.pop ());\r\n    }\r\n\r\n    public static DoubleSequence getDoubleSequence (Object o)\r\n    {\r\n        if (o instanceof DoubleSequence)\r\n        {\r\n            return (DoubleSequence) o;\r\n        }\r\n        if (o instanceof String)\r\n        {\r\n            return new DoubleSequence ((String) o);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static Fraction pow (Fraction f, Long n)\r\n    {\r\n        int denom = (int) Math.pow (f.getDenominator (), n);\r\n        int num = (int) Math.pow (f.getNumerator (), n);\r\n        return Fraction.getReducedFraction (num, denom);\r\n    }\r\n\r\n    public static BigInteger pow (BigInteger a, BigInteger b)\r\n    {\r\n        return a.pow (b.intValue ());\r\n    }\r\n\r\n    public static Double add (Double a, Double b)\r\n    {\r\n        return a + b;\r\n    }\r\n\r\n    public static DoubleMatrix add (DoubleMatrix a, DoubleMatrix b)\r\n    {\r\n        BlockRealMatrix res = a.add (b);\r\n        return new DoubleMatrix (res);\r\n    }\r\n\r\n    public static DoubleMatrix sub (DoubleMatrix a, DoubleMatrix b)\r\n    {\r\n        BlockRealMatrix res = a.subtract (b);\r\n        return new DoubleMatrix (res);\r\n    }\r\n\r\n    public static DoubleMatrix mult (DoubleMatrix a, DoubleMatrix b)\r\n    {\r\n        BlockRealMatrix res = a.multiply (b);\r\n        return new DoubleMatrix (res);\r\n    }\r\n\r\n    public static DoubleMatrix div (DoubleMatrix a, DoubleMatrix b)\r\n    {\r\n        BlockRealMatrix res = a.multiply (MatrixUtils.inverse (b));\r\n        return new DoubleMatrix (res);\r\n    }\r\n\r\n    public static Double sub (Double a, Double b)\r\n    {\r\n        return a - b;\r\n    }\r\n\r\n    public static Double mult (Double a, Double b)\r\n    {\r\n        return a * b;\r\n    }\r\n\r\n    public static Double div (Double a, Double b)\r\n    {\r\n        return a / b;\r\n    }\r\n\r\n    public static Double doCalcDouble (Object o1, Object o2, TwoFuncs<Double, Double, Double> func) throws Exception\r\n    {\r\n        if (o1 instanceof Double || o2 instanceof Double)\r\n        {\r\n            return func.apply (getDouble (o1), getDouble (o2));\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static Complex doCalcComplex (Object o1, Object o2, TwoFuncs<Complex, Complex, Complex> func) throws Exception\r\n    {\r\n        if (areBothObjectsOfType (o1, o2, Complex.class))\r\n        {\r\n            return func.apply (getComplex (o1), getComplex (o2));\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    private static boolean areBothObjectsOfType (Object o1, Object o2, Class c)\r\n    {\r\n        return (c.isInstance (o1) || c.isInstance (o2));\r\n    }\r\n\r\n    public static Fraction doCalcFraction (Object o1, Object o2, TwoFuncs<Fraction, Fraction, Fraction> func) throws Exception\r\n    {\r\n        if (areBothObjectsOfType (o1, o2, Fraction.class))\r\n        {\r\n            return func.apply (getFrac (o1), getFrac (o2));\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    static private Fraction getFrac (Object o1) throws Exception\r\n    {\r\n        if (o1 instanceof Fraction)\r\n        {\r\n            return (Fraction) o1;\r\n        }\r\n        if (o1 instanceof Long)\r\n        {\r\n            return new Fraction ((Long) o1);\r\n        }\r\n        if (o1 instanceof Double)\r\n        {\r\n            return new Fraction ((Double) o1);\r\n        }\r\n        if (o1 instanceof BigInteger)\r\n        {\r\n            return new Fraction (((BigInteger) o1).longValue ());\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static BigInteger doCalcBigInt (Object o1,\r\n                                           Object o2,\r\n                                           TwoFuncs<BigInteger, BigInteger, BigInteger> func) throws Exception\r\n    {\r\n        if (areBothObjectsOfType (o1, o2, BigInteger.class))\r\n        {\r\n            return func.apply (getBig (o1), getBig (o2));\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    public static DoubleMatrix doCalcMatrix (Object o1, Object o2, TwoFuncs<DoubleMatrix, DoubleMatrix, DoubleMatrix> func) throws Exception\r\n    {\r\n        if (areBothObjectsOfType (o1, o2, DoubleMatrix.class))\r\n        {\r\n            return func.apply (getMatrix (o1), getMatrix (o2));\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    static private DoubleMatrix getMatrix (Object o1) throws Exception\r\n    {\r\n        if (o1 instanceof DoubleMatrix)\r\n        {\r\n            return (DoubleMatrix) o1;\r\n        }\r\n        throw new Exception (\"Wrong args\");\r\n    }\r\n\r\n    static public boolean containsIgnoreCase (String original, String pattern)\r\n    {\r\n        if (original == null || pattern == null)\r\n        {\r\n            return true;\r\n        }\r\n        return original.toUpperCase ().contains (pattern.toUpperCase ());\r\n    }\r\n\r\n    /**\r\n     * Copy resource from jar to temp folder\r\n     *\r\n     * @param name name of resource\r\n     * @return Full path to extracted file\r\n     * @throws IOException if smth gone wrong\r\n     */\r\n    static public String extractResource (String name) throws IOException\r\n    {\r\n        String tempName = System.getProperty (\"java.io.tmpdir\") + name;\r\n        if (!new File (tempName).exists ())\r\n        {\r\n            InputStream is = ClassLoader.getSystemResourceAsStream (name);\r\n            BufferedInputStream bis = new BufferedInputStream (Objects.requireNonNull (is));\r\n            OutputStream os = new FileOutputStream (tempName);\r\n            byte[] buff = new byte[1024];\r\n            for (; ; )\r\n            {\r\n                int r = bis.read (buff);\r\n                if (r == -1)\r\n                {\r\n                    break;\r\n                }\r\n                os.write (buff, 0, r);\r\n            }\r\n            bis.close ();\r\n            os.close ();\r\n        }\r\n        return tempName;\r\n    }\r\n\r\n    static public ArrayList<Integer> makeCyclicGroup (int generator, int mod) throws Exception\r\n    {\r\n        BigInteger gen = BigInteger.valueOf (generator);\r\n        ArrayList<Integer> list = new ArrayList<> ();\r\n        BigInteger p = BigInteger.valueOf (generator);\r\n        for (; ; )\r\n        {\r\n            BigInteger m2 = p.mod (BigInteger.valueOf (mod));\r\n            p = p.multiply (gen);\r\n            int m2i = m2.intValue ();\r\n            if (list.contains (m2i))\r\n            {\r\n                break;\r\n            }\r\n            if (m2i == 0)\r\n            {\r\n                throw new Exception (\"Got a ZERO\");\r\n            }\r\n            list.add (m2i);\r\n        }\r\n        if (!list.contains (1))\r\n        {\r\n            throw new Exception (\"Missing 1-element\");\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Multiplicative Inverses of group\r\n     *\r\n     * @param group The multiplicative group\r\n     * @param mod   the modulus\r\n     * @return Arraylist of inverses in the same order as input\r\n     */\r\n/*\r\n    static public ArrayList<Integer> groupInverses (int[] group, int mod)\r\n    {\r\n        ArrayList<Integer> inv = new ArrayList<> ();\r\n        for (int i : group)\r\n        {\r\n            for (int v1 : group)\r\n            {\r\n                if ((v1 * i) % mod == 1)\r\n                {\r\n                    inv.add (v1);\r\n                }\r\n            }\r\n        }\r\n        return inv;\r\n    }\r\n*/\r\n    /**\r\n     * Multiplicative Inverses of group\r\n     *\r\n     * @param group The multiplicative group\r\n     * @param mod   the modulus\r\n     * @return Arraylist of inverses in the same order as input\r\n     */\r\n    static public ArrayList<Integer> groupInverses (int[] group, int mod)\r\n    {\r\n        ArrayList<Integer> inv = new ArrayList<> ();\r\n        for (int a : group)\r\n        {\r\n            long[] retvals = ExtendedGCD (mod, a);\r\n            if (retvals[2] < 0)\r\n            {\r\n                retvals[2] = mod + retvals[2];\r\n            }\r\n            inv.add ((int) retvals[2]);\r\n        }\r\n        return inv;\r\n    }\r\n\r\n    /**\r\n     * Euclidian ext GCD\r\n     *\r\n     * @param a test candidate 1\r\n     * @param b test canditate 2\r\n     * @return three integers:  i[0] = a*i[1] + b*i[2]\r\n     */\r\n    public static long[] ExtendedGCD (long a, long b)\r\n    {\r\n        long[] retvals = {0, 0, 0};\r\n        long[] aa = {1, 0};\r\n        long[] bb = {0, 1};\r\n        long q;\r\n        while (true)\r\n        {\r\n            q = a / b;\r\n            a = a % b;\r\n            aa[0] = aa[0] - q * aa[1];\r\n            bb[0] = bb[0] - q * bb[1];\r\n            if (a == 0)\r\n            {\r\n                retvals[0] = b;\r\n                retvals[1] = aa[1];\r\n                retvals[2] = bb[1];\r\n                return retvals;\r\n            }\r\n            q = b / a;\r\n            b = b % a;\r\n            aa[1] = aa[1] - q * aa[0];\r\n            bb[1] = bb[1] - q * bb[0];\r\n            if (b == 0)\r\n            {\r\n                retvals[0] = a;\r\n                retvals[1] = aa[0];\r\n                retvals[2] = bb[0];\r\n                return retvals;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * rotate an arraylist left\r\n     * @param list the array list\r\n     * @param n number of rotations\r\n     * @param <E> type of objects in that list\r\n     * @return rotated list\r\n     */\r\n    public static <E> ArrayList<E> rotateLeft (ArrayList<E> list, int n)\r\n    {\r\n        return rotateRight (list, list.size ()-n);\r\n    }\r\n\r\n    /**\r\n     * rotate an arraylist right\r\n     * @param list the array list\r\n     * @param n number of rotations\r\n     * @param <E> type of objects in that list\r\n     * @return rotated list\r\n     */\r\n    public static <E> ArrayList<E> rotateRight (ArrayList<E> list, int n)\r\n    {\r\n        ArrayList<E> ret = new ArrayList<> (list);\r\n        Collections.rotate (ret, n);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * rearrange members of an arraylist\r\n     * @param pos array with new positions\r\n     * @param in the arraylist\r\n     * @param <E> type of objects in that list\r\n     * @return a new rearranged arraylist\r\n     */\r\n    public static <E> ArrayList<E> rearrange (int[] pos, ArrayList<E> in)\r\n    {\r\n        ArrayList<E> out = new ArrayList<> ();\r\n        for (int p : pos)\r\n        {\r\n            out.add (in.get (p));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * swap 2 members of an arraylist\r\n     * @param in the list\r\n     * @param a position a\r\n     * @param b position b\r\n     * @param <E> type of objects in the list\r\n     * @return an arraylist with 2 members swapped\r\n     */\r\n    public static <E> ArrayList<E> swap (ArrayList<E> in, int a, int b)\r\n    {\r\n        ArrayList<E> out = new ArrayList<> (in);\r\n        E x = out.get (a);\r\n        out.set (a, out.get (b));\r\n        out.set (b, x);\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * generate textual representation of object\r\n     * @param o the object\r\n     * @param base current number base\r\n     * @return the object as string\r\n     */\r\n    public static String makePrintable (Object o, int base)\r\n    {\r\n        if (o == null)\r\n        {\r\n            return null;\r\n        }\r\n        if (base == -1)\r\n        {\r\n            base = 10;\r\n        }\r\n        if (o instanceof Long)\r\n        {\r\n            return Long.toString ((Long) o, base).toUpperCase ();\r\n        }\r\n        else if (o instanceof Double)\r\n        {\r\n            return Utilities.formatDouble ((Double) o);\r\n        }\r\n        else if (o instanceof Complex)\r\n        {\r\n            return Utilities.formatComplex ((Complex) o);\r\n        }\r\n        else if (o instanceof Fraction)\r\n        {\r\n            return Utilities.formatFraction ((Fraction) o);\r\n        }\r\n        else if (o instanceof String)\r\n        {\r\n            return StringEscape.unescape ((String) o);\r\n        }\r\n        else if (o instanceof PolynomialFunction)\r\n        {\r\n            return PolySupport.formatPoly ((PolynomialFunction) o);\r\n        }\r\n        else if (o instanceof BigInteger)\r\n        {\r\n            return o.toString ();\r\n        }\r\n        else\r\n        {\r\n            return o.toString ();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * shuffle a string\r\n     * @param string input\r\n     * @return the shuffled string\r\n     */\r\n    public static String shuffle (String string)\r\n    {\r\n        List<Character> list = string.chars ().mapToObj (c -> (char) c)\r\n                .collect (Collectors.toList ());\r\n        Collections.shuffle (list);\r\n        StringBuilder sb = new StringBuilder ();\r\n        list.forEach (sb::append);\r\n        return sb.toString ();\r\n    }\r\n\r\n    /**\r\n     * keep only unique chars in string\r\n     * @param string input\r\n     * @return the new string\r\n     */\r\n    public static String unique (String string)\r\n    {\r\n        List<Character> list = string.chars ().mapToObj (c -> (char) c)\r\n                .distinct ()\r\n                .collect (Collectors.toList ());\r\n        StringBuilder sb = new StringBuilder ();\r\n        list.forEach (sb::append);\r\n        return sb.toString ();\r\n    }\r\n\r\n    /**\r\n     * Sort a string\r\n     * @param string input\r\n     * @return a new sorted string\r\n     */\r\n    public static String sort (String string)\r\n    {\r\n       List<Character> list = string.chars ().mapToObj (c -> (char) c).sorted ()\r\n                .collect (Collectors.toList ());\r\n        StringBuilder sb = new StringBuilder ();\r\n        list.forEach (sb::append);\r\n        return sb.toString ();\r\n    }\r\n\r\n    /**\r\n     * Reverse a byte array\r\n     * @param arr input array\r\n     * @return a new reveresed array\r\n     */\r\n    public static byte[] reverse (byte[] arr)\r\n    {\r\n        byte[] res = new byte[arr.length];\r\n        for (int s=0; s<arr.length; s++)\r\n            res[arr.length - 1 - s] = arr[s];\r\n        return res;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/jforth/Utilities.java	(revision e8c784871ce2d456652c5ac6d8716101cdc7690c)
+++ src/jforth/Utilities.java	(date 1601858790772)
@@ -8,9 +8,6 @@
 import org.apache.commons.math3.linear.MatrixUtils;
 import tools.TwoFuncs;
 
-import javax.sound.sampled.AudioSystem;
-import javax.sound.sampled.Clip;
-import javax.sound.sampled.Line;
 import java.io.*;
 import java.math.BigInteger;
 import java.util.ArrayList;
@@ -25,8 +22,8 @@
  */
 public class Utilities
 {
-    private static final String BUILD_NUMBER = "1988";
-    private static final String BUILD_DATE = "09/25/2020 02:29:02 AM";
+    private static final String BUILD_NUMBER = "2005";
+    private static final String BUILD_DATE = "10/05/2020 02:46:14 AM";
 
     public static final String buildInfo = "JForth, Build: " + Utilities.BUILD_NUMBER + ", " + Utilities.BUILD_DATE
             + " -- " + System.getProperty ("java.version");
@@ -977,10 +974,10 @@
      * @return Full path to extracted file
      * @throws IOException if smth gone wrong
      */
-    static public String extractResource (String name) throws IOException
+    static public String extractResource (String name, boolean overwrite) throws IOException
     {
         String tempName = System.getProperty ("java.io.tmpdir") + name;
-        if (!new File (tempName).exists ())
+        if (!new File (tempName).exists () || overwrite)
         {
             InputStream is = ClassLoader.getSystemResourceAsStream (name);
             BufferedInputStream bis = new BufferedInputStream (Objects.requireNonNull (is));
